---
layout: post
title:  "Source Generators - real world example"
date:   2020-11-09 20:41:23 +0100
categories: [roslyn, source-generators, dotnet]
author: dnf
image: assets/images/source_generators_main.png
comments: true
---

This is first post on this blog and I hope it will help you how to write generators. In the post I will be referring SourceGenertors as SG and I will try to show complete real world example with testing, logging and debugging which I took from several sources and figure out by experiments.

#History

Generating code was available in .NET from the beginning. But it always had some drawbacks. We had

- CodeDom which was available since 1.0. It has smaller set of functionality that Roslyn gives and it is out of process because csc.exe is used behind the scene. Additionally it tries to abstract all languages (c# / Vb.NET) and because of that you cant use language specific feature of given language. This API is now deprecated by Roslyn and SourceGenerators
-  T4 allows to generate code by having template written in T4 notation, this template is used by engine with some input data (file or database etc.) to generate code. This technology was commonly used and is definitely not dead but Microsoft is slowly giving up on thin technique in new products. The other thing is to mark that T4 is only template engine so it could be theoretically used in source generator but I don't saw samples to do so. Source generators are little bit more different than template engines.
-  Injecting IL - there are two main tools for this technique. One commercial named Postsharp and open source project Fody. Both use technique named code weaving to inject IL code in build process. This technique allowed us to do Aspect Oriented Programming (AOP) for many years but it has main drawback. Generated code is some kind of black box - something is injected into the code but IDE and compiled is not aware of this code so when you will try to debug very wired things can happened. Because of this magic many people don't want to introduce this techniques to they projects - they are simply not pure code that anybody can navigate to.
-  Roslyn based tools before source generators - there are two in my knowledge https://github.com/AArnott/CodeGeneration.Roslyn and https://github.com/unoplatform/Uno.SourceGeneration. I have used first one and I was rather pleased but it has some drawbacks. Main problem that I see now when comparing to SG is the part when code is generated - in those tools you have to build code with Roslyn objects. It requires you to have good Roslyn knowledge - of course you can support by this helper https://roslynquoter.azurewebsites.net/. I have written many lines of code like those and was happy that it is working but honestly after one day I have to learn it again because it is so complicated. I really like clean code but code written in Roslyn is one I'm ashamed https://github.com/bigdnf/HomeCenter/blob/ea0ca25146797ab1a2d0f67a802a1620d767e9b4/Core/HomeCenter.CodeGeneration/Proxy/ProxyGenerator.cs. Maybe you can clean this code but is is definitely not nice to work with.

[TODO]

# Why

So why we need to generate code? This approach have some useful use cases

1. We are constantly have to write same boilerplate code we could automate this by using SG
2. We have some data files and we need to parse them to have some strongly typed code
3. We have some GUI that is based on file generated by IDE. It could be binary or declarative language - this code can be interpreted by generator
4. We have some code based on reflection which could be slow in runtime - we can generate code in build process and make runtime fast. Microsoft has already some ideas to improve serialization, GRPC and other code in codebase.

those are few examples but I think that there are many of them and they will start to grow when people will understand what kind of tool they have in their hands.

# Introduction

SourceGenerators are part of the Roslyn family tools. Roslyn have great possibilities - it allows you to write code analyzers and fixes to guard your code, perform whole compile process inside your code (I will show this technique later) and many others. Now with .NET 5 Roslyn SDK will be equipped with new feature named Source Generators. 

You have to notice that .NET 5 SDK and VisualStudio/Msbuild 16.8 is required for build the project. There is no limitations I'm aware of to run this code only in .NET 5. Samples provided by MS on github are using .NET 3.1 as runtime https://github.com/dotnet/roslyn-sdk/blob/master/samples/CSharp/SourceGenerators/GeneratedDemo/GeneratedDemo.csproj#L5. 

SG are now part of compiling process and allows you to inject into code compilation process. As a programmer you have Roslyn compilation tree as input and you can add something to this compilation. One important thing is that Microsoft is not allowing to change anything so you could only add something to code but not change existing code.

To start with SG you have to create .NET Standard 2.0 with nuget Microsoft.CodeAnalysis.CSharp in version minimum 3.8. The simplest code looks like below. Note you have to inherit from ISourceGenerator and decorate class with Generator attribute. The main code is to generate source code using compilation or additional files which we will take about later. And this is basically all - note that generated code is in form of c# code (currently only c# is supported - vb will probably be added but f# is different and now it is not planned). 
So in contrast to currently existing techniques you can use any template engine like T4 or other to generate code. In our example I will use Scriban. 
The other parameter named identifier has to be unique and it identifies generated code.
Initialize method currently allows registering analyzers - this will be explained in next section.

```c#
[Generator]
public class ActorProxySourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource(identifier, generatedCode);
    }
}
```

Now having the basic knowledge we can dig deeper in each aspect. We will refer to complete example you could find here [TODO]

# Analyze - Compilation

One of teh main part of source generation is to interpret some input before we generate code. It is good practices to separate this process and build model that will be used in next step. One input we can use is Compilation on its own. Bu having this object you have access to Sytanx Trees and SematicModels of whole solutions. I will not dig deep into those topics because it is candidate for separate article. In short SyntaxTree is parsed model of your source code so everything you see in source code you will see in them. But remember that Syntax Trees are only parsed text and are not aware of full model that is available in semantic model. 
For example when you have class with some base you could get the name of the base class but if you would try to tell something more about this base class you can't having only syntax tree of your class because it is only a name. You could search in all SytnaxTrees and find what you want by getting syntax tree of base class. By getting semantic model you will get something more because semantic model is now interpreted and you have access to types and you can for example go to whole base types chain of your class.
To get semantic model from syntaxtree you have to simply use

[TODO]compilation.GetSemanticModel(classSyntax.SyntaxTree)

Microsoft is recommending to search the compilation using object called SyntaxReceivers. This objects use visitor pattern and during compilation process each receiver is iterating on all SyntaxNodes (Sytax tree as name sound is a tree of code elements and each node of this tree is SyntaxNode). Your custom receiver can decide if this node is candidate for code generation. In our example we have some custom Attribute named ProxyAttribute - when found on the class it is saved to internal list.

[TODO] Code

Note that we have some extensions to Roslyn that simplify reading the code - yuo can find them here: [TODO]

You can register receiver in Initialize method of generator.

public void Initialize(GeneratorInitializationContext context)
{
    context.RegisterForSyntaxNotifications(() => new ActorSyntaxReceiver());
}

When Execute method is called you can access your receiver by SyntaxReceiver property of given context and next you could iterate by all classes you have found.

if (context.SyntaxReceiver is ActorSyntaxReceiver actorSyntaxReciver)
{
    foreach (var proxy in actorSyntaxReciver.CandidateProxies)
    {

When you start playing with analyzing syntax trees it is hard to dig thru all that Roslyn objects. I recommend to install .NET Compiler Platform SDK - it is available as separate component in VS Installer. After installing it in VS you have SyntaxVisualizer window that will visualize each file open currently in IDE. This give quick way to see how syntax tree is structured.

In our example we have GetModel method that is extracting all information from model. As I mentioned earlier I will not explain whole code - you should do this as exercise to see how this could be done.
[TODO] private ProxyModel GetModel(ClassDeclarationSyntax classSyntax, Compilation compilation)

# Analyze - Additional Files

CodeGenerators give additional way for generators to gather information and generate model basing on them. In code using generator you have special section named AdditionalFiles

<ItemGroup>
    <AdditionalFiles Include="Test.txt" />
</ItemGroup>

You can add all the files you want in that section and then you could read them by accessing context.AdditionalFiles. This collection have objects with Path property that shows path to the file and GetText() method that gives you content. Having those information you can basically do anything - for example parse json/xml/csv and build model you like.

# Template

I told before that real power of SG is possibility to use any template engine. For this example after some research I found that for generating c# best way will be https://github.com/lunet-io/scriban. I chose it because it has powerful template features and performance is very good and measured. Of course performance is not most important thing because code generation is one time job but good performance is always right way to distinguish from.

In our example we prepared template: [TODO]

When comparing this code to code generated manually in Roslyn I showed on the beginning it is like comparing day to night. You can see exactly what code will be generated. Now you can also understand why I spoke about generating model in first place. When you have good model now everything you should do is put properties in right place and you are done.

I will not dig into template syntax because you could read about this in docs but for short introduction you are accessing model properties using two angle brackets {% raw %} {{ }} {% endraw %}. For iterating you use {% raw %} {{for element in model.Collection}} {% endraw %}. I also used special for properties like for.end and for.index that gives information saying if we are currently in last iteration and index of the iteration. I also used '-' and '~' to format whitespaces and # sign to add comments. This is basically all functionality I have used - I suggest to read about all functionality of Scriban for your own.

Having model and template you just execute engine and get result

[TODO]

Additionally we are checking if parsing template is successful and use other Roslyn feature to format the code - yes you could to this kind of thing also ;)

One thing to note is way we are storing our templates - I saw samples by having them as string assigned to variables in same code we have our model and rest of the code. Personally I like to put templates in separate files - it is cleaner and all aligning like spaces/tabs are easier to do. The only thing you should do in this approach is to change those file Build Action to Embedded Resources and read them using some helper code [TODO]. In later section I will show how to add all files we want as Embedded Resources using MsBuild way. 

Having code generated we are basically done in development of main component but there are many important aspect to say about.

# Testing

Testing is very important part of every developer process. When writing code generators it is must have for me. Personally I wrote my code using UnitTest code and when I was done I get to integrate this code in application. In this section I will show how using Roslyn you can prepare test environment that allows you to execute SG in isolation.

Every test should have AAA (Arrange, Act, Assert) structure - when testing generators we should have input and output classes for arrange and assert part because our test will read this sample and test if we generated expected output. Same as with templates I prefer to put input and output as separate files from which I'm reading in my test. When comparing I'm using extension method AssertSourceCodesEquals that is removing all white spaces and compare code without them - this is because we don't want our test fail because of difference in some white spaces.

Our 'Act' part of the test is using two important things. First is one feature of Roslyn I was talking on the beginning - we can do code compilation inside code itself because that Roslyn is compiler as a service. This process is very straightforward - we just give list of source codes of our project, add additional references we are using - in example I have added all assemblies from solution by project name to filter out all the rest. Note that I'm using .NET Core feature DependencyContext.Default.RuntimeLibraries that gives me all libs used in solution - this approach don't have drawback of other methods that get only assemblies already used so in runtime. Next we add some core assembly get from type typeof(Binder) and create compilation. Remember then adding all dependent libraries is important because when something is not in tree, compilation is created but you will get empty result for some searches - for example I was searching for base class in semantic model and without all dependent assemblies I just have null result.

Having compilation in place we can use CG class CSharpGeneratorDriver.Create [TODO] to run our custom SG and get results. We can than compare generated output or check diagnostic outputs.

With this infrastructure in place we can write our custom SG and test them without using them in actual code. When everything is tasted we can go into the wild but there are still some important topics.

# Msbuild

Note that things defined below describe in context of using SG as project reference - I don't have time to play with nuget approach in this version.

Apart integration with Roslyn we have integration with MsBuild. To use our custom SG we have to use it in another project - we cannot define and use SG in one project. In preview we have to use

<LangVersion>preview</LangVersion>

to compile our project and we have to use MsBuild **16.8**. Next thing is when we are adding reference to SG we have to add **OutputItemType** and **ReferenceOutputAssembly** attributes to indicate that we are using this code only and build time feature and we don't want this libs in final solutions - because after code generation we don't need SG in production code.

<ProjectReference Include="..\HomeCenter.SourceGenerators\HomeCenter.SourceGenerators.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />

Additionally we can use variables defined in our project file (that project that is using SG) and read them in SG. For example we have defined couple variables 

<SourceGenerator_EnableLogging>True</SourceGenerator_EnableLogging>
<SourceGenerator_EnableDebug>False</SourceGenerator_EnableDebug>
<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>

to allow reading them we have to mark them as CompilerVisibile

<CompilerVisibleProperty Include="SourceGenerator_EnableLogging" />
<CompilerVisibleProperty Include="SourceGenerator_DetailedLog" />
<CompilerVisibleProperty Include="SourceGenerator_EnableDebug" />

after this we can use code like below to read properties using **context.AnalyzerConfigOptions** by name 'build_property.ProperyName'. We can also add some additional attributes to additional files ane read them in similar matter 'build_metadata.AdditionalFiles.PropertyName'

[TODO]

There is also a way to add this properties to .editorconfig file but to be visible in global section of context.AnalyzerConfigOptions we have to mark .editorconfig as **'is_global = true'**. When we don't use this switch property is available only for syntax tree part of AnalyzerConfigOptions. What is this? Configuration can be global (first in example), can be get by AdditionalFile reference or syntaxtrees. For beginning it is hard to dig into this and that is why I wrote some code that dumps all config values - it is part of the logging process described below. Important thing is that this code is using reflection because MS decided to hide this so it is for learning/debugging purposes but it can break in future versions.

[TODO]

Having this dump we can easily see all variables we can use and see if we properly defined our custom variables.

Next thing in Msbuild topic is automatically change all files with template extensions to Embedded Resources - we can do this in Directory.Build.Props - this files allow us add common setting to all project files in solution. It is convenient way to have some common place nad not repeat ourselves in each file. Keep in mind that those files are not hierarchical by design so when we put one file like this it applies to all projects below in directory tree but it stops on this files (unlike .editorconfig which read all file down to root drive). We can change this behavior by using technique described here: https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2019#directorybuildprops-and-directorybuildtargets

<Import Project="$([MSBuild]::GetPathOfFileAbove('Directory.Build.props', '$(MSBuildThisFileDirectory)../'))" />

Last thing in this topic is using additional libraries in our SG. Solution descried below is only needed when we are using project references. With nuget situation is different. In our SG we are using Scriban and when we try to use our SG in some project we will have error that Scriban library is not found. We can fix that manually using approach from sample

https://github.com/dotnet/roslyn-sdk/blob/master/samples/CSharp/SourceGenerators/SourceGeneratorSamples/SourceGeneratorSamples.csproj#L26

So we have to mark nuget reference with GeneratePathProperty="true" and then use generated name in TargetPathWithTargetPlatformMoniker. 

Alternatively we can automate this like me. We only just add attribute I created LocalSourceGenerators and with some MsBuild magic we can automatically add all code.

[TODO]

# Logging 

When creating this kind of code for first time it is hard to spot errors so some diagnostic is very helpful. **When we have proper code** all we need is use 

 <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>

 in project that is using our SG. After this switch set in our obj/generated folder of this project we will have generated code but for me this is not enough. This is why I created logging mechanism that we will use to

 - log generated files
 - log dump of all options (described previously - this is only available when detailed logging is turned on by SourceGenerator_DetailedLog=true)
 - log errors

Logging is only available when SourceGenerator_EnableLogging is set - we can also alter path SourceGenerator_LogPath (Default is obj folder of our SG). Logger sources can be found here [TODO]

Additionally when something wrong is happening we can use Diagnostic available via ReportDiagnostic function of our context. We can event attach information from this diagnostic to specific line of code.

Last thing in our example is code that will generate empty class when something wrong is happening with some error details

[TODO]

# Debugging

Debugging is also useful in first stage of development or when we have some wired situation and logging is not enough. Luckily debugging is really easy - all we need to do is to add

Debugger.Launch();

but to do it more pro we can do it behind some configuration so when SourceGenerator_EnableDebug is set debugging is enabled for all SG and when use SourceGenerator_EnableDebug_SGType when SgType is type of our SG then only for this generator debugger will be attached. When setting this when we build our code there will be prompt what VS to use and then we can debug our code.

Important note - generator code is reload when VS is loading - when we change it sometimes we have to reload VS to see effects. This is another reason why writing most of the code in UnitTest is so important.

# IDE support

For now support in tooling is poor and it is changing in each version of VS - I hope that in final VS we will have some basics like go to definition. This option works for me once but now I have error in VS even when project is compiling - when it worked it navigates to code with some yellow indicator that code is generated and cannot be changed.

We can fix this like this  https://github.com/kzu/ThisAssembly/blob/main/src/GeneratorExtension.cs#L9

but I decided to wait for final release. There are also some plans for some events or api that will allow to reload code of the SG so we will not have to reload whole IDE each time.

# Summary

I hope I described whole process of using generating code - one thing that lacks is using CG in nuget which maybe I will describe in future post. You can also read about this in section below.

# Useful links

- https://www.cazzulino.com/ThisAssembly/
- https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.cookbook.md
- https://jaylee.org/archive/2020/09/13/msbuild-items-and-properties-in-csharp9-sourcegenerators.html
- https://github.com/lunet-io/scriban